
## Working “gold standard” for pg_partman v5 (monthly RANGE on `created_at`)

### 0) Sanity: what version + schema?

```sql
SELECT n.nspname AS ext_schema, e.extversion
FROM pg_extension e
JOIN pg_namespace n ON n.oid = e.extnamespace
WHERE e.extname = 'pg_partman';
```

If `ext_schema` is `partman`, use `partman.create_parent(...)` explicitly (recommended).

---

## 1) Create the parent as a *native partitioned table*

**Important change vs your original:** the PK must include `created_at`.

```sql
CREATE TABLE public.events (
    event_id     bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at   timestamptz NOT NULL,
    event_type   text        NOT NULL,
    payload      jsonb       NOT NULL,
    source       text        NOT NULL,
    inserted_at  timestamptz NOT NULL DEFAULT now(),
    PRIMARY KEY (created_at, event_id)
) PARTITION BY RANGE (created_at);
```

Why this PK: Postgres can only enforce uniqueness across partitions if the constraint includes the partition key. ([Percona][3])

---

## 2) Hand it to pg_partman (v5 style)

Use `range` (not `native`) and your interval.

```sql
SELECT partman.create_parent(
    p_parent_table := 'public.events',
    p_control      := 'created_at',
    p_type         := 'range',
    p_interval     := '1 month',
    p_premake      := 3
);
```

if you want only currnt add future partitions add: **p_start_partition**

```sql
SELECT partman.create_parent(
    p_parent_table    := 'public.events',
    p_control         := 'created_at',
    p_type            := 'range',
    p_interval        := '1 month',
    p_premake         := 3,
    p_start_partition := date_trunc('month', now())::timestamptz
);
```

---

## 3) Indexing strategy (on parent)

These will propagate to partitions (verify after).

```sql
CREATE INDEX ON public.events (created_at);
CREATE INDEX ON public.events (event_type);
CREATE INDEX ON public.events (source);
```

Verify created child indexes:

```sql
SELECT tablename, indexname
FROM pg_indexes
WHERE tablename LIKE 'events_%'
ORDER BY tablename, indexname;
```

---

## 4) Retention policy (drop old partitions)

Example: keep 13 months.

```sql
UPDATE partman.part_config
SET retention = '13 months',
    retention_keep_table = false,
    retention_keep_index = false
WHERE parent_table = 'public.events';
```

Retention is applied during maintenance. ([Keith F4][4])

---

## 5) Maintenance scheduling

Run every 5 minutes (safe).

**If you use pg_cron:**

```sql
SELECT cron.schedule(
  'partman_maintenance',
  '*/5 * * * *',
  $$SELECT partman.run_maintenance();$$
);
```

(Equivalent maintenance functions exist depending on version; `run_maintenance()` is widely used in current docs/blogs. ([postgresql.fastware.com][5]))

---

## 6) Template table (optional, but great)

This gives you central control over indexes/storage settings.

```sql
SELECT partman.create_template('public.events');
```

Then edit the template:

```sql
ALTER TABLE partman.template_public_events
  SET (fillfactor = 90);

CREATE INDEX ON partman.template_public_events (event_type);
```

Push template changes out:

```sql
SELECT partman.refresh_template('public.events');
```

---


[1]: https://github.com/pgpartman/pg_partman?utm_source=chatgpt.com "Partition management extension for PostgreSQL"
[2]: https://github.com/pgpartman/pg_partman/discussions/691?utm_source=chatgpt.com "native is not a valid partitioning type for pg_partman #691"
[3]: https://www.percona.com/blog/postgresql-partitioning-made-easy-using-pg_partman-timebased/?utm_source=chatgpt.com "PostgreSQL Partitioning Made Easy Using pg_partman"
[4]: https://www.keithf4.com/partman-retention/?utm_source=chatgpt.com "Managing Retention with PG Partition Manager"
[5]: https://www.postgresql.fastware.com/pzone/2024-11-managing-fujitsu-enterprise-postgres-partitions-with-pg-partman?utm_source=chatgpt.com "Managing Fujitsu Enterprise Postgres partitions with ..."
