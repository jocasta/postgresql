**`IDENTITY` columns** are the modern, standards-compliant replacement for `SERIAL`.

Let’s be precise about *why* and *how* you should use them.

---

## Old way: `SERIAL` (legacy, PostgreSQL-specific)

```sql
id SERIAL PRIMARY KEY
```

What actually happens:

* Creates a sequence behind the scenes
* Sets a `DEFAULT nextval('seq')`
* Ties them together **implicitly**

Problems:

* Not SQL-standard
* Sequence is “magical” and hidden
* Easy to accidentally break (drop sequence, restore dumps, etc.)
* Less explicit control

`SERIAL` isn’t *deprecated*, but it **should not be used in new schemas**.

---

## New way: `GENERATED AS IDENTITY` (recommended)

```sql
id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY
```

or

```sql
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
```

This is:

* **SQL standard**
* Explicit
* Safer for tooling, dumps, logical replication, and schema diff tools
* What Postgres has been steering people toward since **PostgreSQL 10**

---

## `ALWAYS` vs `BY DEFAULT` (important)

### `GENERATED ALWAYS AS IDENTITY`

* PostgreSQL **always** generates the value
* You **cannot** insert your own ID (unless you override)

```sql
INSERT INTO t DEFAULT VALUES;   -- OK
INSERT INTO t (id) VALUES (5);  -- ❌ ERROR
```

Use when:

* You want **strict control**
* IDs should *never* be user-supplied

---

### `GENERATED BY DEFAULT AS IDENTITY`

* PostgreSQL generates the value **unless you supply one**

```sql
INSERT INTO t DEFAULT VALUES;   -- OK
INSERT INTO t (id) VALUES (5);  -- OK
```

Use when:

* You do data loads
* You restore from backups
* You migrate data between systems

**This is what most people want in practice.**

---

## Always prefer `BIGINT`

If you’re designing anything non-trivial:

```sql
id BIGINT GENERATED BY DEFAULT AS IDENTITY
```

Why:

* `INT` caps out at ~2.1 billion
* With modern systems, that’s not theoretical anymore
* `BIGINT` overhead is negligible

---

## Full modern example (best practice)

```sql
CREATE TABLE orders (
    id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

---

## Can you still access the sequence?

Yes — but now it’s **explicitly owned** by the column:

```sql
ALTER TABLE orders
ALTER COLUMN id RESTART WITH 1000000;
```

No more guessing the sequence name.

---

## When *not* to use identity

You might still **manually manage sequences** if:

* You need **gap-free numbering** (rare, and expensive)
* You generate IDs outside Postgres (UUIDs, Snowflake-style IDs)
* You need sharding-aware ID generation

Otherwise: **use identity**.

---

## Migration from `SERIAL` → `IDENTITY`

Postgres supports this cleanly:

```sql
ALTER TABLE my_table
ALTER COLUMN id
ADD GENERATED BY DEFAULT AS IDENTITY;
```

(No data rewrite.)

---

## Bottom line (DBA-level guidance)

* ❌ Don’t use `SERIAL` in new schemas
* ✅ Use `BIGINT GENERATED BY DEFAULT AS IDENTITY`
* ✅ Use `ALWAYS` only when you truly need strict enforcement
* ✅ Identity columns are safer for **logical replication**, **schema diffs**, and **IaC**

If you want, I can also cover:

* Identity vs UUID (and performance)
* Identity with logical replication
* Identity in Aurora / RDS specifics
* Gotchas with ORMs (Rails, Hibernate, etc.)

Just say the word.
